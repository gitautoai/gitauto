<commit_quality_rules>
  <code_quality_requirement>
    <instruction>Before committing, review your code as if you ran standard linting/formatting tools for that language and fix any issues they would detect.</instruction>
    <examples>
      <typescript>Issues that tsc --noEmit would catch (syntax errors, type issues)</typescript>
      <python>Issues that pylint, pyright, black, or ruff check --fix would catch (unused imports, formatting, style violations)</python>
      <other_languages>Apply the same principle - fix issues that standard linters/formatters for that language would detect</other_languages>
    </examples>
    <rationale>For JavaScript/TypeScript files, ESLint is automatically run with the repository's configuration and fixes are applied. For other languages, you have the knowledge to identify and fix these common issues manually. This prevents CI/CD failures and expensive fix cycles.</rationale>
  </code_quality_requirement>

  <test_rules>
  <value_focused_testing>
    <rule>Test behavior, not implementation details (Behavioral Testing approach)</rule>
    <rule>Focus on what result is returned rather than which internal function is called</rule>
    <rule>Test scenarios (e.g., owner exists, repo doesn't exist) not internal function calls</rule>
  </value_focused_testing>

  <mock_management>
    <rule>PREFER test framework fixtures/setup methods for mock configuration over configuring mocks inside individual test functions. Ensure proper mock lifecycle management (Python example: use yield with with patch() in fixtures)</rule>
    <rule>Create descriptive fixture/setup names that clearly indicate what is being mocked</rule>
    <rule>Handle fixture parameter name conflicts (Python example: use # pylint: disable=redefined-outer-name)</rule>
    <rule>For method chaining operations (e.g., database operations), mock the entire operation as one unit rather than each individual step in the chain (Contract Testing approach) - avoid complex setups like mock.obj.method1.return_value.method2.return_value.method3.return_value</rule>
  </mock_management>

  <test_design_principles>
    <rule>Avoid testing internal implementation details</rule>
    <rule>Tests should not break when refactoring internal code structure</rule>
    <rule>Assert on meaningful outcomes, not intermediate steps</rule>
    <rule>Keep tests independent and focused on single responsibilities</rule>
  </test_design_principles>

  <test_file_organization>
    <rule>Create exactly ONE test file per source file</rule>
    <rule>NEVER create multiple test files like test_get_user_new.py, test_get_user_temp.py, test_get_user.py.deprecated</rule>
    <rule>All test cases for a single source file should be consolidated into one test file</rule>
    <rule>Use descriptive test method names within the single test file to organize different test scenarios</rule>
  </test_file_organization>

  <anti_patterns>
    <rule>Do not test implementation details instead of user-facing behavior</rule>
    <rule>Do not create tests that break when refactoring internal code structure</rule>
    <rule>Do not over-assert on internal function call parameters when the behavior is what matters</rule>
    <rule>NEVER create multiple test files like test_get_user_new.py, test_get_user_temp.py, test_get_user.py.deprecated for the same source file</rule>
    <rule>Do not create unnecessarily complex mock chains when testing method chaining - focus on the final result, not each step of the chain</rule>
    <rule>Do not test constant content (values, text, or any content within constants) unless explicitly requested - tests should not fail when constant values are updated</rule>
  </anti_patterns>
  </test_rules>
</commit_quality_rules> 